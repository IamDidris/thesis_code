The provided code implements an AVL tree, a self-balancing binary search tree that maintains its height balance by performing rotations upon insertions and deletions.  This ensures that lookup, insertion, and deletion operations remain efficient, with a time complexity of O(log n).   How It Works Data Structure:  The AVL tree consists of nodes (AVLTreeNode), each holding a key, value, child pointers (left and right), a parent pointer, and a height attribute.  The tree itself (AVLTree) maintains a reference to the root node, a comparison function for ordering keys, and a count of stored nodes.  Core Operations:  Insertion (avl_tree_insert):  A new node is added at the appropriate position based on key comparison.  After insertion, the tree checks balance factors and performs rotations (avl_tree_rotate) if needed.  Deletion (avl_tree_remove):  The node is removed, and if necessary, a replacement is chosen from its subtree. The tree is then rebalanced upwards to maintain AVL properties.  Searching (avl_tree_lookup):  The tree is traversed using the comparison function to find a node by key.  Balancing (avl_tree_node_balance):  The balance factor of nodes is checked to determine if rotations are required. Single or double rotations restore balance.  Additional Utilities:  Convert tree keys into an ordered array (avl_tree_to_array). Retrieve node relationships (parent, child). Fetch tree statistics (height, number of nodes).  Overall, this AVL tree implementation efficiently manages ordered key-value pairs while ensuring optimal performance through balancing.